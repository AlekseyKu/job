/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/vivus";
exports.ids = ["vendor-chunks/vivus"];
exports.modules = {

/***/ "(ssr)/./node_modules/vivus/dist/vivus.js":
/*!******************************************!*\
  !*** ./node_modules/vivus/dist/vivus.js ***!
  \******************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.4.6\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n(function () {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element instanceof window.SVGElement || \n      element instanceof window.SVGGElement ||\n      /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage.\n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n      elements = svg.querySelectorAll(this.TYPES.join(','));\n\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {},\n      x1 = element.x1 || 0,\n      y1 = element.y1 || 0,\n      x2 = element.x2 || 0,\n      y2 = element.y2 || 0;\n\n  newElement.d = 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n      x      = parseFloat(element.x)      || 0,\n      y      = parseFloat(element.y)      || 0,\n      width  = parseFloat(element.width)  || 0,\n      height = parseFloat(element.height) || 0;\n\n  if (element.rx || element.ry) {\n    var rx = parseInt(element.rx, 10) || -1,\n        ry = parseInt(element.ry, 10) || -1;\n    rx = Math.min(Math.max(rx < 0 ? ry : rx, 0), width/2);\n    ry = Math.min(Math.max(ry < 0 ? rx : ry, 0), height/2);\n\n    newElement.d = 'M ' + (x + rx) + ',' + y + ' ' +\n                   'L ' + (x + width - rx) + ',' + y + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width) + ',' + (y + ry) + ' ' +\n                   'L ' + (x + width) + ',' + (y + height - ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width - rx) + ',' + (y + height) + ' ' +\n                   'L ' + (x + rx) + ',' + (y + height) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + x + ',' + (y + height - ry) + ' ' +\n                   'L ' + x + ',' + (y + ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + rx) + ',' + y;\n  }\n  else {\n    newElement.d = 'M' + x + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + (y + height) + ' ' +\n                   'L' + x + ' ' + (y + height) + ' Z';\n  }\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var newElement = {},\n      points = element.points.trim().split(' '),\n      i, path;\n\n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var newElement = {},\n      rx = parseFloat(element.rx) || 0,\n      ry = parseFloat(element.ry) || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - rx,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(rx),\n      endY = cy;\n\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {},\n      r  = parseFloat(element.r)  || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - r,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(r),\n      endY = cy;\n      \n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar setupEnv, requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'sync'|'oneByOne'|'script' (to know if the items must be drawn synchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'sync'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus(element, options, callback) {\n  setupEnv();\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n **************************************\n *\n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR = function(x) {\n  return x;\n};\nVivus.EASE = function(x) {\n  return -Math.cos(x * Math.PI) / 2 + 0.5;\n};\nVivus.EASE_OUT = function(x) {\n  return 1 - Math.pow(1 - x, 3);\n};\nVivus.EASE_IN = function(x) {\n  return Math.pow(x, 3);\n};\nVivus.EASE_OUT_BOUNCE = function(x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base, 1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI))) + 1;\n  return 1 - rateR + progress * rateR;\n};\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function(element, options) {\n  var onLoad, self;\n\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not related to an existing ID'\n      );\n    }\n  }\n  this.parentEl = element;\n\n  // Load the SVG with XMLHttpRequest and extract the SVG\n  if (options && options.file) {\n    self = this;\n    onLoad = function() {\n      var domSandbox = document.createElement('div');\n      domSandbox.innerHTML = this.responseText;\n\n      var svgTag = domSandbox.querySelector('svg');\n      if (!svgTag) {\n        throw new Error(\n          'Vivus [load]: Cannot find the SVG in the loaded file : ' +\n            options.file\n        );\n      }\n\n      self.el = svgTag;\n      self.el.setAttribute('width', '100%');\n      self.el.setAttribute('height', '100%');\n      self.parentEl.appendChild(self.el);\n      self.isReady = true;\n      self.init();\n      self = null;\n    };\n\n    var oReq = new window.XMLHttpRequest();\n    oReq.addEventListener('load', onLoad);\n    oReq.open('GET', options.file);\n    oReq.send();\n    return;\n  }\n\n  switch (element.constructor) {\n    case window.SVGSVGElement:\n    case window.SVGElement:\n    case window.SVGGElement:\n      this.el = element;\n      this.isReady = true;\n      break;\n\n    case window.HTMLObjectElement:\n      self = this;\n      onLoad = function(e) {\n        if (self.isReady) {\n          return;\n        }\n        self.el =\n          element.contentDocument &&\n          element.contentDocument.querySelector('svg');\n        if (!self.el && e) {\n          throw new Error(\n            'Vivus [constructor]: object loaded does not contain any SVG'\n          );\n        } else if (self.el) {\n          if (element.getAttribute('built-by-vivus')) {\n            self.parentEl.insertBefore(self.el, element);\n            self.parentEl.removeChild(element);\n            self.el.setAttribute('width', '100%');\n            self.el.setAttribute('height', '100%');\n          }\n          self.isReady = true;\n          self.init();\n          self = null;\n        }\n      };\n\n      if (!onLoad()) {\n        element.addEventListener('load', onLoad);\n      }\n      break;\n\n    default:\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)'\n      );\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function(options) {\n  var allowedTypes = [\n    'delayed',\n    'sync',\n    'async',\n    'nsync',\n    'oneByOne',\n    'scenario',\n    'scenario-sync'\n  ];\n  var allowedStarts = ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error(\n      'Vivus [constructor]: \"options\" parameter must be an object'\n    );\n  } else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.type +\n        ' is not an existing animation `type`'\n    );\n  } else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.start +\n        ' is not an existing `start` option'\n    );\n  } else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE =\n    window.navigator.userAgent.indexOf('MSIE') !== -1 ||\n    window.navigator.userAgent.indexOf('Trident/') !== -1 ||\n    window.navigator.userAgent.indexOf('Edge/') !== -1;\n  this.duration = parsePositiveInt(options.duration, 120);\n  this.delay = parsePositiveInt(options.delay, null);\n  this.dashGap = parsePositiveInt(options.dashGap, 1);\n  this.forceRender = options.hasOwnProperty('forceRender')\n    ? !!options.forceRender\n    : this.isIE;\n  this.reverseStack = !!options.reverseStack;\n  this.selfDestroy = !!options.selfDestroy;\n  this.onReady = options.onReady;\n  this.map = [];\n  this.frameLength = this.currentFrame = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible')\n    ? !!options.ignoreInvisible\n    : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function(callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error(\n      'Vivus [constructor]: \"callback\" parameter must be a function'\n    );\n  }\n  this.callback = callback || function() {};\n};\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function() {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint, scale, hasNonScale;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n  hasNonScale = false;\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n\n    pathObj = {\n      el: path,\n      length: 0,\n      startAt: 0,\n      duration: 0,\n      isResizeSensitive: false\n    };\n\n    // If vector effect is non-scaling-stroke, the total length won't match the rendered length\n    // so we need to calculate the scale and apply it\n    if (path.getAttribute('vector-effect') === 'non-scaling-stroke') {\n      var rect = path.getBoundingClientRect();\n      var box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.isResizeSensitive = true;\n      hasNonScale = true;\n    } else {\n      scale = 1;\n    }\n    pathObj.length = Math.ceil(path.getTotalLength() * scale);\n\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn(\n          'Vivus [mapping]: cannot retrieve a path element length',\n          path\n        );\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray =\n      pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  // Show a warning for non-scaling elements\n  if (hasNonScale) {\n    console.warn('Vivus: this SVG contains non-scaling-strokes. You should call instance.recalc() when the SVG is resized or you will encounter unwanted behaviour. See https://github.com/maxwellito/vivus#non-scaling for more info.');\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  // Reverse stack if asked\n  if (this.reverseStack) {\n    this.map.reverse();\n  }\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n      case 'delayed':\n        pathObj.startAt = this.delayUnit * i;\n        pathObj.duration = this.duration - this.delay;\n        break;\n\n      case 'oneByOne':\n        pathObj.startAt = (lengthMeter / totalLength) * this.duration;\n        pathObj.duration = (pathObj.length / totalLength) * this.duration;\n        break;\n\n      case 'sync':\n      case 'async':\n      case 'nsync':\n        pathObj.startAt = 0;\n        pathObj.duration = this.duration;\n        break;\n\n      case 'scenario-sync':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          timePoint +\n          (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        timePoint =\n          pAttrs['data-async'] !== undefined\n            ? pathObj.startAt\n            : pathObj.startAt + pathObj.duration;\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n\n      case 'scenario':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Public method to re-evaluate line length for non-scaling lines\n * path elements.\n */\nVivus.prototype.recalc = function () {\n  if (this.mustRecalcScale) {\n    return;\n  }\n  this.mustRecalcScale = requestAnimFrame(function () {\n    this.performLineRecalc();\n  }.bind(this));\n}\n\n/**\n * Private method to re-evaluate line length on non-scaling\n * path elements. Then call for a trace to update the SVG. \n */\nVivus.prototype.performLineRecalc = function () {\n  var pathObj, path, rect, box, scale;\n  for (var i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n    if (pathObj.isResizeSensitive) {\n      path = pathObj.el;\n      rect = path.getBoundingClientRect();\n      box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.length = Math.ceil(path.getTotalLength() * scale);\n      path.style.strokeDasharray = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    }\n  }\n  this.trace();\n  this.mustRecalcScale = null;\n}\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.draw = function() {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function() {\n      self.draw();\n    });\n    return;\n  }\n\n  this.callback(this);\n  if (this.instanceCallback) {\n    this.instanceCallback(this);\n    this.instanceCallback = null;\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function() {\n  var i, progress, path, currentFrame;\n  currentFrame =\n    this.animTimingFunction(this.currentFrame / this.frameLength) *\n    this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n *\n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function(index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n      newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n *\n */\nVivus.prototype.init = function() {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function() {\n  switch (this.start) {\n    case 'manual':\n      return;\n\n    case 'autostart':\n      this.play();\n      break;\n\n    case 'inViewport':\n      var self = this,\n        listener = function() {\n          if (self.isInViewport(self.parentEl, 1)) {\n            self.play();\n            window.removeEventListener('scroll', listener);\n          }\n        };\n      window.addEventListener('scroll', listener);\n      listener();\n      break;\n  }\n};\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function() {\n  return this.currentFrame === 0\n    ? 'start'\n    : this.currentFrame === this.frameLength\n    ? 'end'\n    : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function() {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function() {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n *\n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function(progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function(speed, callback) {\n  this.instanceCallback = null;\n\n  if (speed && typeof speed === 'function') {\n    this.instanceCallback = speed; // first parameter is actually the callback function\n    speed = null;\n  } else if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  // if the first parameter wasn't the callback, check if the seconds was\n  if (callback && typeof callback === 'function' && !this.instanceCallback) {\n    this.instanceCallback = callback;\n  }\n\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.draw();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function() {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function() {\n  this.stop();\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function(el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function(element) {\n  var attr,\n    output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function(el, h) {\n  var scrolled = this.scrollY(),\n    viewed = scrolled + this.getViewportH(),\n    elBCR = el.getBoundingClientRect(),\n    elHeight = elBCR.height,\n    elTop = scrolled + elBCR.top,\n    elBottom = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return elTop + elHeight * h <= viewed && elBottom >= scrolled;\n};\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function() {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  } else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function() {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\nsetupEnv = function() {\n  if (Vivus.prototype.docElem) {\n    return;\n  }\n\n  /**\n   * Alias for document element\n   *\n   * @type {DOMelement}\n   */\n  Vivus.prototype.docElem = window.document.documentElement;\n\n  /**\n   * Alias for `requestAnimationFrame` or\n   * `setTimeout` function for deprecated browsers.\n   *\n   */\n  requestAnimFrame = (function() {\n    return (\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(/* function */ callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      }\n    );\n  })();\n\n  /**\n   * Alias for `cancelAnimationFrame` or\n   * `cancelTimeout` function for deprecated browsers.\n   *\n   */\n  cancelAnimFrame = (function() {\n    return (\n      window.cancelAnimationFrame ||\n      window.webkitCancelAnimationFrame ||\n      window.mozCancelAnimationFrame ||\n      window.oCancelAnimationFrame ||\n      window.msCancelAnimationFrame ||\n      function(id) {\n        return window.clearTimeout(id);\n      }\n    );\n  })();\n};\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function(value, defaultValue) {\n  var output = parseInt(value, 10);\n  return output >= 0 ? output : defaultValue;\n};\n\n\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return Vivus;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdml2dXMvZGlzdC92aXZ1cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QixZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QixXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxxQkFBcUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtCQUErQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsSUFBSSxpQ0FBTyxFQUFFLG1DQUFFO0FBQ2Y7QUFDQSxLQUFLO0FBQUEsa0dBQUM7QUFDTixJQUFJLEtBQUssRUFRTjs7QUFFSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXlrZC1uZXh0Ly4vbm9kZV9tb2R1bGVzL3ZpdnVzL2Rpc3Qvdml2dXMuanM/Y2Y5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZpdnVzIC0gSmF2YVNjcmlwdCBsaWJyYXJ5IHRvIG1ha2UgZHJhd2luZyBhbmltYXRpb24gb24gU1ZHXG4gKiBAdmVyc2lvbiB2MC40LjZcbiAqIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXh3ZWxsaXRvL3ZpdnVzXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBQYXRoZm9ybWVyXG4gKiBCZXRhIHZlcnNpb25cbiAqXG4gKiBUYWtlIGFueSBTVkcgdmVyc2lvbiAxLjEgYW5kIHRyYW5zZm9ybVxuICogY2hpbGQgZWxlbWVudHMgdG8gJ3BhdGgnIGVsZW1lbnRzXG4gKlxuICogVGhpcyBjb2RlIGlzIHB1cmVseSBmb3JrZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1dhZXN0L1NWR1BhdGhDb252ZXJ0ZXJcbiAqL1xuXG4vKipcbiAqIENsYXNzIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtET018U3RyaW5nfSBlbGVtZW50IERvbSBlbGVtZW50IG9mIHRoZSBTVkcgb3IgaWQgb2YgaXRcbiAqL1xuZnVuY3Rpb24gUGF0aGZvcm1lcihlbGVtZW50KSB7XG4gIC8vIFRlc3QgcGFyYW1zXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGhmb3JtZXIgW2NvbnN0cnVjdG9yXTogXCJlbGVtZW50XCIgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICAvLyBTZXQgdGhlIGVsZW1lbnRcbiAgaWYgKGVsZW1lbnQuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aGZvcm1lciBbY29uc3RydWN0b3JdOiBcImVsZW1lbnRcIiBwYXJhbWV0ZXIgaXMgbm90IHJlbGF0ZWQgdG8gYW4gZXhpc3RpbmcgSUQnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCB8fCBcbiAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHR0VsZW1lbnQgfHxcbiAgICAgIC9ec3ZnJC9pLnRlc3QoZWxlbWVudC5ub2RlTmFtZSkpIHtcbiAgICB0aGlzLmVsID0gZWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGhmb3JtZXIgW2NvbnN0cnVjdG9yXTogXCJlbGVtZW50XCIgcGFyYW1ldGVyIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBTVkdlbGVtZW50Jyk7XG4gIH1cblxuICAvLyBTdGFydFxuICB0aGlzLnNjYW4oZWxlbWVudCk7XG59XG5cbi8qKlxuICogTGlzdCBvZiB0YWdzIHdoaWNoIGNhbiBiZSB0cmFuc2Zvcm1lZFxuICogdG8gcGF0aCBlbGVtZW50c1xuICpcbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuUGF0aGZvcm1lci5wcm90b3R5cGUuVFlQRVMgPSBbJ2xpbmUnLCAnZWxsaXBzZScsICdjaXJjbGUnLCAncG9seWdvbicsICdwb2x5bGluZScsICdyZWN0J107XG5cbi8qKlxuICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgd2hpY2ggY29udGFpblxuICogZGF0YS4gVGhpcyBhcnJheSBsaXN0IHRoZW0gdG8gY2hlY2sgaWZcbiAqIHRoZXkgY29udGFpbiBiYWQgdmFsdWVzLCBsaWtlIHBlcmNlbnRhZ2UuXG4gKlxuICogQHR5cGUge0FycmF5fVxuICovXG5QYXRoZm9ybWVyLnByb3RvdHlwZS5BVFRSX1dBVENIID0gWydjeCcsICdjeScsICdwb2ludHMnLCAncicsICdyeCcsICdyeScsICd4JywgJ3gxJywgJ3gyJywgJ3knLCAneTEnLCAneTInXTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgZWxlbWVudHMgY29tcGF0aWJsZSBmb3IgdHJhbnNmb3JtXG4gKiBhbmQgYXBwbHkgdGhlIGxpa2VkIG1ldGhvZFxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBPYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAqL1xuUGF0aGZvcm1lci5wcm90b3R5cGUuc2NhbiA9IGZ1bmN0aW9uIChzdmcpIHtcbiAgdmFyIGZuLCBlbGVtZW50LCBwYXRoRGF0YSwgcGF0aERvbSxcbiAgICAgIGVsZW1lbnRzID0gc3ZnLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5UWVBFUy5qb2luKCcsJykpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgZm4gPSB0aGlzW2VsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICsgJ1RvUGF0aCddO1xuICAgIHBhdGhEYXRhID0gZm4odGhpcy5wYXJzZUF0dHIoZWxlbWVudC5hdHRyaWJ1dGVzKSk7XG4gICAgcGF0aERvbSA9IHRoaXMucGF0aE1ha2VyKGVsZW1lbnQsIHBhdGhEYXRhKTtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHBhdGhEb20sIGVsZW1lbnQpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVhZCBgbGluZWAgZWxlbWVudCB0byBleHRyYWN0IGFuZCB0cmFuc2Zvcm1cbiAqIGRhdGEsIHRvIG1ha2UgaXQgcmVhZHkgZm9yIGEgYHBhdGhgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtET01lbGVtZW50fSBlbGVtZW50IExpbmUgZWxlbWVudCB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgRGF0YSBmb3IgYSBgcGF0aGAgZWxlbWVudFxuICovXG5QYXRoZm9ybWVyLnByb3RvdHlwZS5saW5lVG9QYXRoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSB7fSxcbiAgICAgIHgxID0gZWxlbWVudC54MSB8fCAwLFxuICAgICAgeTEgPSBlbGVtZW50LnkxIHx8IDAsXG4gICAgICB4MiA9IGVsZW1lbnQueDIgfHwgMCxcbiAgICAgIHkyID0gZWxlbWVudC55MiB8fCAwO1xuXG4gIG5ld0VsZW1lbnQuZCA9ICdNJyArIHgxICsgJywnICsgeTEgKyAnTCcgKyB4MiArICcsJyArIHkyO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogUmVhZCBgcmVjdGAgZWxlbWVudCB0byBleHRyYWN0IGFuZCB0cmFuc2Zvcm1cbiAqIGRhdGEsIHRvIG1ha2UgaXQgcmVhZHkgZm9yIGEgYHBhdGhgIG9iamVjdC5cbiAqIFRoZSByYWRpdXMtYm9yZGVyIGlzIG5vdCB0YWtlbiBpbiBjaGFyZ2UgeWV0LlxuICogKHlvdXIgaGVscCBpcyBtb3JlIHRoYW4gd2VsY29tZWQpXG4gKlxuICogQHBhcmFtICB7RE9NZWxlbWVudH0gZWxlbWVudCBSZWN0IGVsZW1lbnQgdG8gdHJhbnNmb3JtXG4gKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgICAgIERhdGEgZm9yIGEgYHBhdGhgIGVsZW1lbnRcbiAqL1xuUGF0aGZvcm1lci5wcm90b3R5cGUucmVjdFRvUGF0aCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBuZXdFbGVtZW50ID0ge30sXG4gICAgICB4ICAgICAgPSBwYXJzZUZsb2F0KGVsZW1lbnQueCkgICAgICB8fCAwLFxuICAgICAgeSAgICAgID0gcGFyc2VGbG9hdChlbGVtZW50LnkpICAgICAgfHwgMCxcbiAgICAgIHdpZHRoICA9IHBhcnNlRmxvYXQoZWxlbWVudC53aWR0aCkgIHx8IDAsXG4gICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KGVsZW1lbnQuaGVpZ2h0KSB8fCAwO1xuXG4gIGlmIChlbGVtZW50LnJ4IHx8IGVsZW1lbnQucnkpIHtcbiAgICB2YXIgcnggPSBwYXJzZUludChlbGVtZW50LnJ4LCAxMCkgfHwgLTEsXG4gICAgICAgIHJ5ID0gcGFyc2VJbnQoZWxlbWVudC5yeSwgMTApIHx8IC0xO1xuICAgIHJ4ID0gTWF0aC5taW4oTWF0aC5tYXgocnggPCAwID8gcnkgOiByeCwgMCksIHdpZHRoLzIpO1xuICAgIHJ5ID0gTWF0aC5taW4oTWF0aC5tYXgocnkgPCAwID8gcnggOiByeSwgMCksIGhlaWdodC8yKTtcblxuICAgIG5ld0VsZW1lbnQuZCA9ICdNICcgKyAoeCArIHJ4KSArICcsJyArIHkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICdMICcgKyAoeCArIHdpZHRoIC0gcngpICsgJywnICsgeSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgJ0EgJyArIHJ4ICsgJywnICsgcnkgKyAnLDAsMCwxLCcgKyAoeCArIHdpZHRoKSArICcsJyArICh5ICsgcnkpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAnTCAnICsgKHggKyB3aWR0aCkgKyAnLCcgKyAoeSArIGhlaWdodCAtIHJ5KSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgJ0EgJyArIHJ4ICsgJywnICsgcnkgKyAnLDAsMCwxLCcgKyAoeCArIHdpZHRoIC0gcngpICsgJywnICsgKHkgKyBoZWlnaHQpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAnTCAnICsgKHggKyByeCkgKyAnLCcgKyAoeSArIGhlaWdodCkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICdBICcgKyByeCArICcsJyArIHJ5ICsgJywwLDAsMSwnICsgeCArICcsJyArICh5ICsgaGVpZ2h0IC0gcnkpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAnTCAnICsgeCArICcsJyArICh5ICsgcnkpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAnQSAnICsgcnggKyAnLCcgKyByeSArICcsMCwwLDEsJyArICh4ICsgcngpICsgJywnICsgeTtcbiAgfVxuICBlbHNlIHtcbiAgICBuZXdFbGVtZW50LmQgPSAnTScgKyB4ICsgJyAnICsgeSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgJ0wnICsgKHggKyB3aWR0aCkgKyAnICcgKyB5ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAnTCcgKyAoeCArIHdpZHRoKSArICcgJyArICh5ICsgaGVpZ2h0KSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgJ0wnICsgeCArICcgJyArICh5ICsgaGVpZ2h0KSArICcgWic7XG4gIH1cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG4vKipcbiAqIFJlYWQgYHBvbHlsaW5lYCBlbGVtZW50IHRvIGV4dHJhY3QgYW5kIHRyYW5zZm9ybVxuICogZGF0YSwgdG8gbWFrZSBpdCByZWFkeSBmb3IgYSBgcGF0aGAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge0RPTWVsZW1lbnR9IGVsZW1lbnQgUG9seWxpbmUgZWxlbWVudCB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgRGF0YSBmb3IgYSBgcGF0aGAgZWxlbWVudFxuICovXG5QYXRoZm9ybWVyLnByb3RvdHlwZS5wb2x5bGluZVRvUGF0aCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHZhciBuZXdFbGVtZW50ID0ge30sXG4gICAgICBwb2ludHMgPSBlbGVtZW50LnBvaW50cy50cmltKCkuc3BsaXQoJyAnKSxcbiAgICAgIGksIHBhdGg7XG5cbiAgLy8gUmVmb3JtYXR0aW5nIGlmIHBvaW50cyBhcmUgZGVmaW5lZCB3aXRob3V0IGNvbW1hc1xuICBpZiAoZWxlbWVudC5wb2ludHMuaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIHZhciBmb3JtYXR0ZWRQb2ludHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSs9Mikge1xuICAgICAgZm9ybWF0dGVkUG9pbnRzLnB1c2gocG9pbnRzW2ldICsgJywnICsgcG9pbnRzW2krMV0pO1xuICAgIH1cbiAgICBwb2ludHMgPSBmb3JtYXR0ZWRQb2ludHM7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSB0aGUgcGF0aC5kIHZhbHVlXG4gIHBhdGggPSAnTScgKyBwb2ludHNbMF07XG4gIGZvcihpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwb2ludHNbaV0uaW5kZXhPZignLCcpICE9PSAtMSkge1xuICAgICAgcGF0aCArPSAnTCcgKyBwb2ludHNbaV07XG4gICAgfVxuICB9XG4gIG5ld0VsZW1lbnQuZCA9IHBhdGg7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBSZWFkIGBwb2x5Z29uYCBlbGVtZW50IHRvIGV4dHJhY3QgYW5kIHRyYW5zZm9ybVxuICogZGF0YSwgdG8gbWFrZSBpdCByZWFkeSBmb3IgYSBgcGF0aGAgb2JqZWN0LlxuICogVGhpcyBtZXRob2QgcmVseSBvbiBwb2x5bGluZVRvUGF0aCwgYmVjYXVzZSB0aGVcbiAqIGxvZ2ljIGlzIHNpbWlsYXIuIFRoZSBwYXRoIGNyZWF0ZWQgaXMganVzdCBjbG9zZWQsXG4gKiBzbyBpdCBuZWVkcyBhbiAnWicgYXQgdGhlIGVuZC5cbiAqXG4gKiBAcGFyYW0gIHtET01lbGVtZW50fSBlbGVtZW50IFBvbHlnb24gZWxlbWVudCB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgRGF0YSBmb3IgYSBgcGF0aGAgZWxlbWVudFxuICovXG5QYXRoZm9ybWVyLnByb3RvdHlwZS5wb2x5Z29uVG9QYXRoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBQYXRoZm9ybWVyLnByb3RvdHlwZS5wb2x5bGluZVRvUGF0aChlbGVtZW50KTtcblxuICBuZXdFbGVtZW50LmQgKz0gJ1onO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogUmVhZCBgZWxsaXBzZWAgZWxlbWVudCB0byBleHRyYWN0IGFuZCB0cmFuc2Zvcm1cbiAqIGRhdGEsIHRvIG1ha2UgaXQgcmVhZHkgZm9yIGEgYHBhdGhgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtET01lbGVtZW50fSBlbGVtZW50IGVsbGlwc2UgZWxlbWVudCB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgRGF0YSBmb3IgYSBgcGF0aGAgZWxlbWVudFxuICovXG5QYXRoZm9ybWVyLnByb3RvdHlwZS5lbGxpcHNlVG9QYXRoID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSB7fSxcbiAgICAgIHJ4ID0gcGFyc2VGbG9hdChlbGVtZW50LnJ4KSB8fCAwLFxuICAgICAgcnkgPSBwYXJzZUZsb2F0KGVsZW1lbnQucnkpIHx8IDAsXG4gICAgICBjeCA9IHBhcnNlRmxvYXQoZWxlbWVudC5jeCkgfHwgMCxcbiAgICAgIGN5ID0gcGFyc2VGbG9hdChlbGVtZW50LmN5KSB8fCAwLFxuICAgICAgc3RhcnRYID0gY3ggLSByeCxcbiAgICAgIHN0YXJ0WSA9IGN5LFxuICAgICAgZW5kWCA9IHBhcnNlRmxvYXQoY3gpICsgcGFyc2VGbG9hdChyeCksXG4gICAgICBlbmRZID0gY3k7XG5cbiAgbmV3RWxlbWVudC5kID0gJ00nICsgc3RhcnRYICsgJywnICsgc3RhcnRZICtcbiAgICAgICAgICAgICAgICAgJ0EnICsgcnggKyAnLCcgKyByeSArICcgMCwxLDEgJyArIGVuZFggKyAnLCcgKyBlbmRZICtcbiAgICAgICAgICAgICAgICAgJ0EnICsgcnggKyAnLCcgKyByeSArICcgMCwxLDEgJyArIHN0YXJ0WCArICcsJyArIGVuZFk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBSZWFkIGBjaXJjbGVgIGVsZW1lbnQgdG8gZXh0cmFjdCBhbmQgdHJhbnNmb3JtXG4gKiBkYXRhLCB0byBtYWtlIGl0IHJlYWR5IGZvciBhIGBwYXRoYCBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7RE9NZWxlbWVudH0gZWxlbWVudCBDaXJjbGUgZWxlbWVudCB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgRGF0YSBmb3IgYSBgcGF0aGAgZWxlbWVudFxuICovXG5QYXRoZm9ybWVyLnByb3RvdHlwZS5jaXJjbGVUb1BhdGggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgbmV3RWxlbWVudCA9IHt9LFxuICAgICAgciAgPSBwYXJzZUZsb2F0KGVsZW1lbnQucikgIHx8IDAsXG4gICAgICBjeCA9IHBhcnNlRmxvYXQoZWxlbWVudC5jeCkgfHwgMCxcbiAgICAgIGN5ID0gcGFyc2VGbG9hdChlbGVtZW50LmN5KSB8fCAwLFxuICAgICAgc3RhcnRYID0gY3ggLSByLFxuICAgICAgc3RhcnRZID0gY3ksXG4gICAgICBlbmRYID0gcGFyc2VGbG9hdChjeCkgKyBwYXJzZUZsb2F0KHIpLFxuICAgICAgZW5kWSA9IGN5O1xuICAgICAgXG4gIG5ld0VsZW1lbnQuZCA9ICAnTScgKyBzdGFydFggKyAnLCcgKyBzdGFydFkgK1xuICAgICAgICAgICAgICAgICAgJ0EnICsgciArICcsJyArIHIgKyAnIDAsMSwxICcgKyBlbmRYICsgJywnICsgZW5kWSArXG4gICAgICAgICAgICAgICAgICAnQScgKyByICsgJywnICsgciArICcgMCwxLDEgJyArIHN0YXJ0WCArICcsJyArIGVuZFk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYHBhdGhgIGVsZW1lbnRzIGZvcm0gb3JpZ2luYWwgZWxlbWVudFxuICogYW5kIHByZXBhcmVkIG9iamVjdHNcbiAqXG4gKiBAcGFyYW0gIHtET01lbGVtZW50fSBlbGVtZW50ICBPcmlnaW5hbCBlbGVtZW50IHRvIHRyYW5zZm9ybVxuICogQHBhcmFtICB7b2JqZWN0fSBwYXRoRGF0YSAgICAgUGF0aCBkYXRhIChmcm9tIGB0b1BhdGhgIG1ldGhvZHMpXG4gKiBAcmV0dXJuIHtET01lbGVtZW50fSAgICAgICAgICBQYXRoIGVsZW1lbnRcbiAqL1xuUGF0aGZvcm1lci5wcm90b3R5cGUucGF0aE1ha2VyID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhdGhEYXRhKSB7XG4gIHZhciBpLCBhdHRyLCBwYXRoVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsJ3BhdGgnKTtcbiAgZm9yKGkgPSAwOyBpIDwgZWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXR0ciA9IGVsZW1lbnQuYXR0cmlidXRlc1tpXTtcbiAgICBpZiAodGhpcy5BVFRSX1dBVENILmluZGV4T2YoYXR0ci5uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHBhdGhUYWcuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgfVxuICB9XG4gIGZvcihpIGluIHBhdGhEYXRhKSB7XG4gICAgcGF0aFRhZy5zZXRBdHRyaWJ1dGUoaSwgcGF0aERhdGFbaV0pO1xuICB9XG4gIHJldHVybiBwYXRoVGFnO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhdHRyaWJ1dGVzIG9mIGEgRE9NIGVsZW1lbnQgdG9cbiAqIGdldCBhbiBvYmplY3Qgb2YgYXR0cmlidXRlID0+IHZhbHVlXG4gKlxuICogQHBhcmFtICB7TmFtZWROb2RlTWFwfSBhdHRyaWJ1dGVzIEF0dHJpYnV0ZXMgb2JqZWN0IGZyb20gRE9NIGVsZW1lbnQgdG8gcGFyc2VcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgICBPYmplY3Qgb2YgYXR0cmlidXRlc1xuICovXG5QYXRoZm9ybWVyLnByb3RvdHlwZS5wYXJzZUF0dHIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgYXR0ciwgb3V0cHV0ID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5sZW5ndGg7IGkrKykge1xuICAgIGF0dHIgPSBlbGVtZW50W2ldO1xuICAgIC8vIENoZWNrIGlmIG5vIGRhdGEgYXR0cmlidXRlIGNvbnRhaW5zICclJywgb3IgdGhlIHRyYW5zZm9ybWF0aW9uIGlzIGltcG9zc2libGVcbiAgICBpZiAodGhpcy5BVFRSX1dBVENILmluZGV4T2YoYXR0ci5uYW1lKSAhPT0gLTEgJiYgYXR0ci52YWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGhmb3JtZXIgW3BhcnNlQXR0cl06IGEgU1ZHIHNoYXBlIGdvdCB2YWx1ZXMgaW4gcGVyY2VudGFnZS4gVGhpcyBjYW5ub3QgYmUgdHJhbnNmb3JtZWQgaW50byBcXCdwYXRoXFwnIHRhZ3MuIFBsZWFzZSB1c2UgXFwndmlld0JveFxcJy4nKTtcbiAgICB9XG4gICAgb3V0cHV0W2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4gICd1c2Ugc3RyaWN0JztcblxudmFyIHNldHVwRW52LCByZXF1ZXN0QW5pbUZyYW1lLCBjYW5jZWxBbmltRnJhbWUsIHBhcnNlUG9zaXRpdmVJbnQ7XG5cbi8qKlxuICogVml2dXNcbiAqIEJldGEgdmVyc2lvblxuICpcbiAqIFRha2UgYW55IFNWRyBhbmQgbWFrZSB0aGUgYW5pbWF0aW9uXG4gKiB0byBnaXZlIGdpdmUgdGhlIGltcHJlc3Npb24gb2YgbGl2ZSBkcmF3aW5nXG4gKlxuICogVGhpcyBpbiBtb3JlIHRoYW4ganVzdCBpbnNwaXJlZCBmcm9tIGNvZHJvcHNcbiAqIEF0IHRoYXQgcG9pbnQsIGl0J3MgYSBwdXJlIGZvcmsuXG4gKi9cblxuLyoqXG4gKiBDbGFzcyBjb25zdHJ1Y3RvclxuICogb3B0aW9uIHN0cnVjdHVyZVxuICogICB0eXBlOiAnZGVsYXllZCd8J3N5bmMnfCdvbmVCeU9uZSd8J3NjcmlwdCcgKHRvIGtub3cgaWYgdGhlIGl0ZW1zIG11c3QgYmUgZHJhd24gc3luY2hyb25vdXNseSBvciBub3QsIGRlZmF1bHQ6IGRlbGF5ZWQpXG4gKiAgIGR1cmF0aW9uOiA8aW50PiAoaW4gZnJhbWVzKVxuICogICBzdGFydDogJ2luVmlld3BvcnQnfCdtYW51YWwnfCdhdXRvc3RhcnQnIChzdGFydCBhdXRvbWF0aWNhbGx5IHRoZSBhbmltYXRpb24sIGRlZmF1bHQ6IGluVmlld3BvcnQpXG4gKiAgIGRlbGF5OiA8aW50PiAoZGVsYXkgYmV0d2VlbiB0aGUgZHJhd2luZyBvZiBmaXJzdCBhbmQgbGFzdCBwYXRoKVxuICogICBkYXNoR2FwIDxpbnRlZ2VyPiB3aGl0ZXNwYWNlIGV4dHJhIG1hcmdpbiBiZXR3ZWVuIGRhc2hlc1xuICogICBwYXRoVGltaW5nRnVuY3Rpb24gPGZ1bmN0aW9uPiB0aW1pbmcgYW5pbWF0aW9uIGZ1bmN0aW9uIGZvciBlYWNoIHBhdGggZWxlbWVudCBvZiB0aGUgU1ZHXG4gKiAgIGFuaW1UaW1pbmdGdW5jdGlvbiA8ZnVuY3Rpb24+IHRpbWluZyBhbmltYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjb21wbGV0ZSBTVkdcbiAqICAgZm9yY2VSZW5kZXIgPGJvb2xlYW4+IGZvcmNlIHRoZSBicm93c2VyIHRvIHJlLXJlbmRlciBhbGwgdXBkYXRlZCBwYXRoIGl0ZW1zXG4gKiAgIHNlbGZEZXN0cm95IDxib29sZWFuPiByZW1vdmVzIGFsbCBleHRyYSBzdHlsaW5nIG9uIHRoZSBTVkcsIGFuZCBsZWF2ZXMgaXQgYXMgb3JpZ2luYWxcbiAqXG4gKiBUaGUgYXR0cmlidXRlICd0eXBlJyBpcyBieSBkZWZhdWx0IG9uICdkZWxheWVkJy5cbiAqICAtICdkZWxheWVkJ1xuICogICAgYWxsIHBhdGhzIGFyZSBkcmF3IGF0IHRoZSBzYW1lIHRpbWUgYnV0IHdpdGggYVxuICogICAgbGl0dGxlIGRlbGF5IGJldHdlZW4gdGhlbSBiZWZvcmUgc3RhcnRcbiAqICAtICdzeW5jJ1xuICogICAgYWxsIHBhdGggYXJlIHN0YXJ0IGFuZCBmaW5pc2ggYXQgdGhlIHNhbWUgdGltZVxuICogIC0gJ29uZUJ5T25lJ1xuICogICAgb25seSBvbmUgcGF0aCBpcyBkcmF3IGF0IHRoZSB0aW1lXG4gKiAgICB0aGUgZW5kIG9mIHRoZSBmaXJzdCBvbmUgd2lsbCB0cmlnZ2VyIHRoZSBkcmF3XG4gKiAgICBvZiB0aGUgbmV4dCBvbmVcbiAqXG4gKiBBbGwgdGhlc2UgdmFsdWVzIGNhbiBiZSBvdmVyd3JpdHRlbiBpbmRpdmlkdWFsbHlcbiAqIGZvciBlYWNoIHBhdGggaXRlbSBpbiB0aGUgU1ZHXG4gKiBUaGUgdmFsdWUgb2YgZnJhbWVzIHdpbGwgYWx3YXlzIHRha2UgdGhlIGFkdmFudGFnZSBvZlxuICogdGhlIGR1cmF0aW9uIHZhbHVlLlxuICogSWYgeW91IGZhaWwgc29tZXdoZXJlLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqIEdvb2QgbHVjay5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEB0aGlzIHtWaXZ1c31cbiAqIEBwYXJhbSB7RE9NfFN0cmluZ30gICBlbGVtZW50ICBEb20gZWxlbWVudCBvZiB0aGUgU1ZHIG9yIGlkIG9mIGl0XG4gKiBAcGFyYW0ge09iamVjdH0gICAgICAgb3B0aW9ucyAgT3B0aW9ucyBhYm91dCB0aGUgYW5pbWF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICAgY2FsbGJhY2sgQ2FsbGJhY2sgZm9yIHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvblxuICovXG5mdW5jdGlvbiBWaXZ1cyhlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBzZXR1cEVudigpO1xuXG4gIC8vIFNldHVwXG4gIHRoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICB0aGlzLnNldEVsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgdGhpcy5zZXRDYWxsYmFjayhjYWxsYmFjayk7XG5cbiAgaWYgKHRoaXMuaXNSZWFkeSkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG59XG5cbi8qKlxuICogVGltaW5nIGZ1bmN0aW9uc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlxuICogRGVmYXVsdCBmdW5jdGlvbnMgdG8gaGVscCBkZXZlbG9wZXJzLlxuICogSXQgYWx3YXlzIHRha2UgYSBudW1iZXIgYXMgcGFyYW1ldGVyIChiZXR3ZWVuIDAgdG8gMSkgdGhlblxuICogcmV0dXJuIGEgbnVtYmVyIChiZXR3ZWVuIDAgYW5kIDEpXG4gKi9cblZpdnVzLkxJTkVBUiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuVml2dXMuRUFTRSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmNvcyh4ICogTWF0aC5QSSkgLyAyICsgMC41O1xufTtcblZpdnVzLkVBU0VfT1VUID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB4LCAzKTtcbn07XG5WaXZ1cy5FQVNFX0lOID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gTWF0aC5wb3coeCwgMyk7XG59O1xuVml2dXMuRUFTRV9PVVRfQk9VTkNFID0gZnVuY3Rpb24oeCkge1xuICB2YXIgYmFzZSA9IC1NYXRoLmNvcyh4ICogKDAuNSAqIE1hdGguUEkpKSArIDEsXG4gICAgcmF0ZSA9IE1hdGgucG93KGJhc2UsIDEuNSksXG4gICAgcmF0ZVIgPSBNYXRoLnBvdygxIC0geCwgMiksXG4gICAgcHJvZ3Jlc3MgPSAtTWF0aC5hYnMoTWF0aC5jb3MocmF0ZSAqICgyLjUgKiBNYXRoLlBJKSkpICsgMTtcbiAgcmV0dXJuIDEgLSByYXRlUiArIHByb2dyZXNzICogcmF0ZVI7XG59O1xuXG4vKipcbiAqIFNldHRlcnNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICovXG5cbi8qKlxuICogQ2hlY2sgYW5kIHNldCB0aGUgZWxlbWVudCBpbiB0aGUgaW5zdGFuY2VcbiAqIFRoZSBtZXRob2Qgd2lsbCBub3QgcmV0dXJuIGFueXRoaW5nLCBidXQgd2lsbCB0aHJvdyBhblxuICogZXJyb3IgaWYgdGhlIHBhcmFtZXRlciBpcyBpbnZhbGlkXG4gKlxuICogQHBhcmFtIHtET018U3RyaW5nfSAgIGVsZW1lbnQgIFNWRyBEb20gZWxlbWVudCBvciBpZCBvZiBpdFxuICovXG5WaXZ1cy5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIG9uTG9hZCwgc2VsZjtcblxuICAvLyBCYXNpYyBjaGVja1xuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWaXZ1cyBbY29uc3RydWN0b3JdOiBcImVsZW1lbnRcIiBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIC8vIFNldCB0aGUgZWxlbWVudFxuICBpZiAoZWxlbWVudC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVml2dXMgW2NvbnN0cnVjdG9yXTogXCJlbGVtZW50XCIgcGFyYW1ldGVyIGlzIG5vdCByZWxhdGVkIHRvIGFuIGV4aXN0aW5nIElEJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wYXJlbnRFbCA9IGVsZW1lbnQ7XG5cbiAgLy8gTG9hZCB0aGUgU1ZHIHdpdGggWE1MSHR0cFJlcXVlc3QgYW5kIGV4dHJhY3QgdGhlIFNWR1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZpbGUpIHtcbiAgICBzZWxmID0gdGhpcztcbiAgICBvbkxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkb21TYW5kYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb21TYW5kYm94LmlubmVySFRNTCA9IHRoaXMucmVzcG9uc2VUZXh0O1xuXG4gICAgICB2YXIgc3ZnVGFnID0gZG9tU2FuZGJveC5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICAgIGlmICghc3ZnVGFnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnVml2dXMgW2xvYWRdOiBDYW5ub3QgZmluZCB0aGUgU1ZHIGluIHRoZSBsb2FkZWQgZmlsZSA6ICcgK1xuICAgICAgICAgICAgb3B0aW9ucy5maWxlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZWwgPSBzdmdUYWc7XG4gICAgICBzZWxmLmVsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xuICAgICAgc2VsZi5lbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgICBzZWxmLnBhcmVudEVsLmFwcGVuZENoaWxkKHNlbGYuZWwpO1xuICAgICAgc2VsZi5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgIHNlbGYuaW5pdCgpO1xuICAgICAgc2VsZiA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciBvUmVxID0gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIG9SZXEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgb1JlcS5vcGVuKCdHRVQnLCBvcHRpb25zLmZpbGUpO1xuICAgIG9SZXEuc2VuZCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5jb25zdHJ1Y3Rvcikge1xuICAgIGNhc2Ugd2luZG93LlNWR1NWR0VsZW1lbnQ6XG4gICAgY2FzZSB3aW5kb3cuU1ZHRWxlbWVudDpcbiAgICBjYXNlIHdpbmRvdy5TVkdHRWxlbWVudDpcbiAgICAgIHRoaXMuZWwgPSBlbGVtZW50O1xuICAgICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSB3aW5kb3cuSFRNTE9iamVjdEVsZW1lbnQ6XG4gICAgICBzZWxmID0gdGhpcztcbiAgICAgIG9uTG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuaXNSZWFkeSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmVsID1cbiAgICAgICAgICBlbGVtZW50LmNvbnRlbnREb2N1bWVudCAmJlxuICAgICAgICAgIGVsZW1lbnQuY29udGVudERvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpO1xuICAgICAgICBpZiAoIXNlbGYuZWwgJiYgZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdWaXZ1cyBbY29uc3RydWN0b3JdOiBvYmplY3QgbG9hZGVkIGRvZXMgbm90IGNvbnRhaW4gYW55IFNWRydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuZWwpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2J1aWx0LWJ5LXZpdnVzJykpIHtcbiAgICAgICAgICAgIHNlbGYucGFyZW50RWwuaW5zZXJ0QmVmb3JlKHNlbGYuZWwsIGVsZW1lbnQpO1xuICAgICAgICAgICAgc2VsZi5wYXJlbnRFbC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIHNlbGYuZWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJyk7XG4gICAgICAgICAgICBzZWxmLmVsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLmluaXQoKTtcbiAgICAgICAgICBzZWxmID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKCFvbkxvYWQoKSkge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVml2dXMgW2NvbnN0cnVjdG9yXTogXCJlbGVtZW50XCIgcGFyYW1ldGVyIGlzIG5vdCB2YWxpZCAob3IgbWlzcyB0aGUgXCJmaWxlXCIgYXR0cmlidXRlKSdcbiAgICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IHVwIHVzZXIgb3B0aW9uIHRvIHRoZSBpbnN0YW5jZVxuICogVGhlIG1ldGhvZCB3aWxsIG5vdCByZXR1cm4gYW55dGhpbmcsIGJ1dCB3aWxsIHRocm93IGFuXG4gKiBlcnJvciBpZiB0aGUgcGFyYW1ldGVyIGlzIGludmFsaWRcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgT2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gKi9cblZpdnVzLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgYWxsb3dlZFR5cGVzID0gW1xuICAgICdkZWxheWVkJyxcbiAgICAnc3luYycsXG4gICAgJ2FzeW5jJyxcbiAgICAnbnN5bmMnLFxuICAgICdvbmVCeU9uZScsXG4gICAgJ3NjZW5hcmlvJyxcbiAgICAnc2NlbmFyaW8tc3luYydcbiAgXTtcbiAgdmFyIGFsbG93ZWRTdGFydHMgPSBbJ2luVmlld3BvcnQnLCAnbWFudWFsJywgJ2F1dG9zdGFydCddO1xuXG4gIC8vIEJhc2ljIGNoZWNrXG4gIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1ZpdnVzIFtjb25zdHJ1Y3Rvcl06IFwib3B0aW9uc1wiIHBhcmFtZXRlciBtdXN0IGJlIGFuIG9iamVjdCdcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG5cbiAgLy8gU2V0IHRoZSBhbmltYXRpb24gdHlwZVxuICBpZiAob3B0aW9ucy50eXBlICYmIGFsbG93ZWRUeXBlcy5pbmRleE9mKG9wdGlvbnMudHlwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1ZpdnVzIFtjb25zdHJ1Y3Rvcl06ICcgK1xuICAgICAgICBvcHRpb25zLnR5cGUgK1xuICAgICAgICAnIGlzIG5vdCBhbiBleGlzdGluZyBhbmltYXRpb24gYHR5cGVgJ1xuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlIHx8IGFsbG93ZWRUeXBlc1swXTtcbiAgfVxuXG4gIC8vIFNldCB0aGUgc3RhcnQgdHlwZVxuICBpZiAob3B0aW9ucy5zdGFydCAmJiBhbGxvd2VkU3RhcnRzLmluZGV4T2Yob3B0aW9ucy5zdGFydCkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1ZpdnVzIFtjb25zdHJ1Y3Rvcl06ICcgK1xuICAgICAgICBvcHRpb25zLnN0YXJ0ICtcbiAgICAgICAgJyBpcyBub3QgYW4gZXhpc3RpbmcgYHN0YXJ0YCBvcHRpb24nXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXJ0ID0gb3B0aW9ucy5zdGFydCB8fCBhbGxvd2VkU3RhcnRzWzBdO1xuICB9XG5cbiAgdGhpcy5pc0lFID1cbiAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdNU0lFJykgIT09IC0xIHx8XG4gICAgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudC8nKSAhPT0gLTEgfHxcbiAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlLycpICE9PSAtMTtcbiAgdGhpcy5kdXJhdGlvbiA9IHBhcnNlUG9zaXRpdmVJbnQob3B0aW9ucy5kdXJhdGlvbiwgMTIwKTtcbiAgdGhpcy5kZWxheSA9IHBhcnNlUG9zaXRpdmVJbnQob3B0aW9ucy5kZWxheSwgbnVsbCk7XG4gIHRoaXMuZGFzaEdhcCA9IHBhcnNlUG9zaXRpdmVJbnQob3B0aW9ucy5kYXNoR2FwLCAxKTtcbiAgdGhpcy5mb3JjZVJlbmRlciA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2ZvcmNlUmVuZGVyJylcbiAgICA/ICEhb3B0aW9ucy5mb3JjZVJlbmRlclxuICAgIDogdGhpcy5pc0lFO1xuICB0aGlzLnJldmVyc2VTdGFjayA9ICEhb3B0aW9ucy5yZXZlcnNlU3RhY2s7XG4gIHRoaXMuc2VsZkRlc3Ryb3kgPSAhIW9wdGlvbnMuc2VsZkRlc3Ryb3k7XG4gIHRoaXMub25SZWFkeSA9IG9wdGlvbnMub25SZWFkeTtcbiAgdGhpcy5tYXAgPSBbXTtcbiAgdGhpcy5mcmFtZUxlbmd0aCA9IHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5kZWxheVVuaXQgPSB0aGlzLnNwZWVkID0gdGhpcy5oYW5kbGUgPSBudWxsO1xuXG4gIHRoaXMuaWdub3JlSW52aXNpYmxlID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnaWdub3JlSW52aXNpYmxlJylcbiAgICA/ICEhb3B0aW9ucy5pZ25vcmVJbnZpc2libGVcbiAgICA6IGZhbHNlO1xuXG4gIHRoaXMuYW5pbVRpbWluZ0Z1bmN0aW9uID0gb3B0aW9ucy5hbmltVGltaW5nRnVuY3Rpb24gfHwgVml2dXMuTElORUFSO1xuICB0aGlzLnBhdGhUaW1pbmdGdW5jdGlvbiA9IG9wdGlvbnMucGF0aFRpbWluZ0Z1bmN0aW9uIHx8IFZpdnVzLkxJTkVBUjtcblxuICBpZiAodGhpcy5kZWxheSA+PSB0aGlzLmR1cmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWaXZ1cyBbY29uc3RydWN0b3JdOiBkZWxheSBtdXN0IGJlIHNob3J0ZXIgdGhhbiBkdXJhdGlvbicpO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCB1cCBjYWxsYmFjayB0byB0aGUgaW5zdGFuY2VcbiAqIFRoZSBtZXRob2Qgd2lsbCBub3QgcmV0dXJuIGVueXRoaW5nLCBidXQgd2lsbCB0aHJvdyBhblxuICogZXJyb3IgaWYgdGhlIHBhcmFtZXRlciBpcyBpbnZhbGlkXG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZvciB0aGUgYW5pbWF0aW9uIGVuZFxuICovXG5WaXZ1cy5wcm90b3R5cGUuc2V0Q2FsbGJhY2sgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAvLyBCYXNpYyBjaGVja1xuICBpZiAoISFjYWxsYmFjayAmJiBjYWxsYmFjay5jb25zdHJ1Y3RvciAhPT0gRnVuY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnVml2dXMgW2NvbnN0cnVjdG9yXTogXCJjYWxsYmFja1wiIHBhcmFtZXRlciBtdXN0IGJlIGEgZnVuY3Rpb24nXG4gICAgKTtcbiAgfVxuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbn07XG5cbi8qKlxuICogQ29yZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKi9cblxuLyoqXG4gKiBNYXAgdGhlIHN2ZywgcGF0aCBieSBwYXRoLlxuICogVGhlIG1ldGhvZCByZXR1cm4gbm90aGluZywgaXQganVzdCBmaWxsIHRoZVxuICogYG1hcGAgYXJyYXkuIEVhY2ggaXRlbSBpbiB0aGlzIGFycmF5IHJlcHJlc2VudFxuICogYSBwYXRoIGVsZW1lbnQgZnJvbSB0aGUgU1ZHLCB3aXRoIGluZm9ybWF0aW9ucyBmb3JcbiAqIHRoZSBhbmltYXRpb24uXG4gKlxuICogYGBgXG4gKiBbXG4gKiAgIHtcbiAqICAgICBlbDogPERPTW9iaj4gdGhlIHBhdGggZWxlbWVudFxuICogICAgIGxlbmd0aDogPG51bWJlcj4gbGVuZ3RoIG9mIHRoZSBwYXRoIGxpbmVcbiAqICAgICBzdGFydEF0OiA8bnVtYmVyPiB0aW1lIHN0YXJ0IG9mIHRoZSBwYXRoIGFuaW1hdGlvbiAoaW4gZnJhbWVzKVxuICogICAgIGR1cmF0aW9uOiA8bnVtYmVyPiBwYXRoIGFuaW1hdGlvbiBkdXJhdGlvbiAoaW4gZnJhbWVzKVxuICogICB9LFxuICogICAuLi5cbiAqIF1cbiAqIGBgYFxuICpcbiAqL1xuVml2dXMucHJvdG90eXBlLm1hcHBpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGksIHBhdGhzLCBwYXRoLCBwQXR0cnMsIHBhdGhPYmosIHRvdGFsTGVuZ3RoLCBsZW5ndGhNZXRlciwgdGltZVBvaW50LCBzY2FsZSwgaGFzTm9uU2NhbGU7XG4gIHRpbWVQb2ludCA9IHRvdGFsTGVuZ3RoID0gbGVuZ3RoTWV0ZXIgPSAwO1xuICBwYXRocyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgncGF0aCcpO1xuICBoYXNOb25TY2FsZSA9IGZhbHNlO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgIHBhdGggPSBwYXRoc1tpXTtcbiAgICBpZiAodGhpcy5pc0ludmlzaWJsZShwYXRoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGF0aE9iaiA9IHtcbiAgICAgIGVsOiBwYXRoLFxuICAgICAgbGVuZ3RoOiAwLFxuICAgICAgc3RhcnRBdDogMCxcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgaXNSZXNpemVTZW5zaXRpdmU6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIElmIHZlY3RvciBlZmZlY3QgaXMgbm9uLXNjYWxpbmctc3Ryb2tlLCB0aGUgdG90YWwgbGVuZ3RoIHdvbid0IG1hdGNoIHRoZSByZW5kZXJlZCBsZW5ndGhcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgc2NhbGUgYW5kIGFwcGx5IGl0XG4gICAgaWYgKHBhdGguZ2V0QXR0cmlidXRlKCd2ZWN0b3ItZWZmZWN0JykgPT09ICdub24tc2NhbGluZy1zdHJva2UnKSB7XG4gICAgICB2YXIgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgYm94ID0gcGF0aC5nZXRCQm94KCk7XG4gICAgICBzY2FsZSA9IE1hdGgubWF4KHJlY3Qud2lkdGggLyBib3gud2lkdGgsIHJlY3QuaGVpZ2h0IC8gYm94LmhlaWdodCk7XG4gICAgICBwYXRoT2JqLmlzUmVzaXplU2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICAgIGhhc05vblNjYWxlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSAxO1xuICAgIH1cbiAgICBwYXRoT2JqLmxlbmd0aCA9IE1hdGguY2VpbChwYXRoLmdldFRvdGFsTGVuZ3RoKCkgKiBzY2FsZSk7XG5cbiAgICAvLyBUZXN0IGlmIHRoZSBwYXRoIGxlbmd0aCBpcyBjb3JyZWN0XG4gICAgaWYgKGlzTmFOKHBhdGhPYmoubGVuZ3RoKSkge1xuICAgICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1ZpdnVzIFttYXBwaW5nXTogY2Fubm90IHJldHJpZXZlIGEgcGF0aCBlbGVtZW50IGxlbmd0aCcsXG4gICAgICAgICAgcGF0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMubWFwLnB1c2gocGF0aE9iaik7XG4gICAgcGF0aC5zdHlsZS5zdHJva2VEYXNoYXJyYXkgPVxuICAgICAgcGF0aE9iai5sZW5ndGggKyAnICcgKyAocGF0aE9iai5sZW5ndGggKyB0aGlzLmRhc2hHYXAgKiAyKTtcbiAgICBwYXRoLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBwYXRoT2JqLmxlbmd0aCArIHRoaXMuZGFzaEdhcDtcbiAgICBwYXRoT2JqLmxlbmd0aCArPSB0aGlzLmRhc2hHYXA7XG4gICAgdG90YWxMZW5ndGggKz0gcGF0aE9iai5sZW5ndGg7XG5cbiAgICB0aGlzLnJlbmRlclBhdGgoaSk7XG4gIH1cblxuICAvLyBTaG93IGEgd2FybmluZyBmb3Igbm9uLXNjYWxpbmcgZWxlbWVudHNcbiAgaWYgKGhhc05vblNjYWxlKSB7XG4gICAgY29uc29sZS53YXJuKCdWaXZ1czogdGhpcyBTVkcgY29udGFpbnMgbm9uLXNjYWxpbmctc3Ryb2tlcy4gWW91IHNob3VsZCBjYWxsIGluc3RhbmNlLnJlY2FsYygpIHdoZW4gdGhlIFNWRyBpcyByZXNpemVkIG9yIHlvdSB3aWxsIGVuY291bnRlciB1bndhbnRlZCBiZWhhdmlvdXIuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF4d2VsbGl0by92aXZ1cyNub24tc2NhbGluZyBmb3IgbW9yZSBpbmZvLicpO1xuICB9XG5cbiAgdG90YWxMZW5ndGggPSB0b3RhbExlbmd0aCA9PT0gMCA/IDEgOiB0b3RhbExlbmd0aDtcbiAgdGhpcy5kZWxheSA9IHRoaXMuZGVsYXkgPT09IG51bGwgPyB0aGlzLmR1cmF0aW9uIC8gMyA6IHRoaXMuZGVsYXk7XG4gIHRoaXMuZGVsYXlVbml0ID0gdGhpcy5kZWxheSAvIChwYXRocy5sZW5ndGggPiAxID8gcGF0aHMubGVuZ3RoIC0gMSA6IDEpO1xuXG4gIC8vIFJldmVyc2Ugc3RhY2sgaWYgYXNrZWRcbiAgaWYgKHRoaXMucmV2ZXJzZVN0YWNrKSB7XG4gICAgdGhpcy5tYXAucmV2ZXJzZSgpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMubWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgcGF0aE9iaiA9IHRoaXMubWFwW2ldO1xuXG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2RlbGF5ZWQnOlxuICAgICAgICBwYXRoT2JqLnN0YXJ0QXQgPSB0aGlzLmRlbGF5VW5pdCAqIGk7XG4gICAgICAgIHBhdGhPYmouZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uIC0gdGhpcy5kZWxheTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29uZUJ5T25lJzpcbiAgICAgICAgcGF0aE9iai5zdGFydEF0ID0gKGxlbmd0aE1ldGVyIC8gdG90YWxMZW5ndGgpICogdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgcGF0aE9iai5kdXJhdGlvbiA9IChwYXRoT2JqLmxlbmd0aCAvIHRvdGFsTGVuZ3RoKSAqIHRoaXMuZHVyYXRpb247XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzeW5jJzpcbiAgICAgIGNhc2UgJ2FzeW5jJzpcbiAgICAgIGNhc2UgJ25zeW5jJzpcbiAgICAgICAgcGF0aE9iai5zdGFydEF0ID0gMDtcbiAgICAgICAgcGF0aE9iai5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzY2VuYXJpby1zeW5jJzpcbiAgICAgICAgcGF0aCA9IHBhdGhPYmouZWw7XG4gICAgICAgIHBBdHRycyA9IHRoaXMucGFyc2VBdHRyKHBhdGgpO1xuICAgICAgICBwYXRoT2JqLnN0YXJ0QXQgPVxuICAgICAgICAgIHRpbWVQb2ludCArXG4gICAgICAgICAgKHBhcnNlUG9zaXRpdmVJbnQocEF0dHJzWydkYXRhLWRlbGF5J10sIHRoaXMuZGVsYXlVbml0KSB8fCAwKTtcbiAgICAgICAgcGF0aE9iai5kdXJhdGlvbiA9IHBhcnNlUG9zaXRpdmVJbnQoXG4gICAgICAgICAgcEF0dHJzWydkYXRhLWR1cmF0aW9uJ10sXG4gICAgICAgICAgdGhpcy5kdXJhdGlvblxuICAgICAgICApO1xuICAgICAgICB0aW1lUG9pbnQgPVxuICAgICAgICAgIHBBdHRyc1snZGF0YS1hc3luYyddICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gcGF0aE9iai5zdGFydEF0XG4gICAgICAgICAgICA6IHBhdGhPYmouc3RhcnRBdCArIHBhdGhPYmouZHVyYXRpb247XG4gICAgICAgIHRoaXMuZnJhbWVMZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgICB0aGlzLmZyYW1lTGVuZ3RoLFxuICAgICAgICAgIHBhdGhPYmouc3RhcnRBdCArIHBhdGhPYmouZHVyYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NjZW5hcmlvJzpcbiAgICAgICAgcGF0aCA9IHBhdGhPYmouZWw7XG4gICAgICAgIHBBdHRycyA9IHRoaXMucGFyc2VBdHRyKHBhdGgpO1xuICAgICAgICBwYXRoT2JqLnN0YXJ0QXQgPVxuICAgICAgICAgIHBhcnNlUG9zaXRpdmVJbnQocEF0dHJzWydkYXRhLXN0YXJ0J10sIHRoaXMuZGVsYXlVbml0KSB8fCAwO1xuICAgICAgICBwYXRoT2JqLmR1cmF0aW9uID0gcGFyc2VQb3NpdGl2ZUludChcbiAgICAgICAgICBwQXR0cnNbJ2RhdGEtZHVyYXRpb24nXSxcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZnJhbWVMZW5ndGggPSBNYXRoLm1heChcbiAgICAgICAgICB0aGlzLmZyYW1lTGVuZ3RoLFxuICAgICAgICAgIHBhdGhPYmouc3RhcnRBdCArIHBhdGhPYmouZHVyYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxlbmd0aE1ldGVyICs9IHBhdGhPYmoubGVuZ3RoO1xuICAgIHRoaXMuZnJhbWVMZW5ndGggPSB0aGlzLmZyYW1lTGVuZ3RoIHx8IHRoaXMuZHVyYXRpb247XG4gIH1cbn07XG5cbi8qKlxuICogUHVibGljIG1ldGhvZCB0byByZS1ldmFsdWF0ZSBsaW5lIGxlbmd0aCBmb3Igbm9uLXNjYWxpbmcgbGluZXNcbiAqIHBhdGggZWxlbWVudHMuXG4gKi9cblZpdnVzLnByb3RvdHlwZS5yZWNhbGMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm11c3RSZWNhbGNTY2FsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLm11c3RSZWNhbGNTY2FsZSA9IHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGVyZm9ybUxpbmVSZWNhbGMoKTtcbiAgfS5iaW5kKHRoaXMpKTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byByZS1ldmFsdWF0ZSBsaW5lIGxlbmd0aCBvbiBub24tc2NhbGluZ1xuICogcGF0aCBlbGVtZW50cy4gVGhlbiBjYWxsIGZvciBhIHRyYWNlIHRvIHVwZGF0ZSB0aGUgU1ZHLiBcbiAqL1xuVml2dXMucHJvdG90eXBlLnBlcmZvcm1MaW5lUmVjYWxjID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGF0aE9iaiwgcGF0aCwgcmVjdCwgYm94LCBzY2FsZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcC5sZW5ndGg7IGkrKykge1xuICAgIHBhdGhPYmogPSB0aGlzLm1hcFtpXTtcbiAgICBpZiAocGF0aE9iai5pc1Jlc2l6ZVNlbnNpdGl2ZSkge1xuICAgICAgcGF0aCA9IHBhdGhPYmouZWw7XG4gICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGJveCA9IHBhdGguZ2V0QkJveCgpO1xuICAgICAgc2NhbGUgPSBNYXRoLm1heChyZWN0LndpZHRoIC8gYm94LndpZHRoLCByZWN0LmhlaWdodCAvIGJveC5oZWlnaHQpO1xuICAgICAgcGF0aE9iai5sZW5ndGggPSBNYXRoLmNlaWwocGF0aC5nZXRUb3RhbExlbmd0aCgpICogc2NhbGUpO1xuICAgICAgcGF0aC5zdHlsZS5zdHJva2VEYXNoYXJyYXkgPSBwYXRoT2JqLmxlbmd0aCArICcgJyArIChwYXRoT2JqLmxlbmd0aCArIHRoaXMuZGFzaEdhcCAqIDIpO1xuICAgIH1cbiAgfVxuICB0aGlzLnRyYWNlKCk7XG4gIHRoaXMubXVzdFJlY2FsY1NjYWxlID0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbnRlcnZhbCBtZXRob2QgdG8gZHJhdyB0aGUgU1ZHIGZyb20gY3VycmVudFxuICogcG9zaXRpb24gb2YgdGhlIGFuaW1hdGlvbi4gSXQgdXBkYXRlIHRoZSB2YWx1ZSBvZlxuICogYGN1cnJlbnRGcmFtZWAgYW5kIHJlLXRyYWNlIHRoZSBTVkcuXG4gKlxuICogSXQgdXNlIHRoaXMuaGFuZGxlIHRvIHN0b3JlIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqIGFuZCBjbGVhciBpdCBvbmUgdGhlIGFuaW1hdGlvbiBpcyBzdG9wcGVkLiBTbyB0aGlzXG4gKiBhdHRyaWJ1dGUgY2FuIGJlIHVzZWQgdG8ga25vdyBpZiB0aGUgYW5pbWF0aW9uIGlzXG4gKiBwbGF5aW5nLlxuICpcbiAqIE9uY2UgdGhlIGFuaW1hdGlvbiBhdCB0aGUgZW5kLCB0aGlzIG1ldGhvZCB3aWxsXG4gKiB0cmlnZ2VyIHRoZSBWaXZ1cyBjYWxsYmFjay5cbiAqXG4gKi9cblZpdnVzLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5jdXJyZW50RnJhbWUgKz0gdGhpcy5zcGVlZDtcblxuICBpZiAodGhpcy5jdXJyZW50RnJhbWUgPD0gMCkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRGcmFtZSA+PSB0aGlzLmZyYW1lTGVuZ3RoKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLmZyYW1lTGVuZ3RoO1xuICAgIHRoaXMudHJhY2UoKTtcbiAgICBpZiAodGhpcy5zZWxmRGVzdHJveSkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMudHJhY2UoKTtcbiAgICB0aGlzLmhhbmRsZSA9IHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmRyYXcoKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmNhbGxiYWNrKHRoaXMpO1xuICBpZiAodGhpcy5pbnN0YW5jZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5pbnN0YW5jZUNhbGxiYWNrKHRoaXMpO1xuICAgIHRoaXMuaW5zdGFuY2VDYWxsYmFjayA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogRHJhdyB0aGUgU1ZHIGF0IHRoZSBjdXJyZW50IGluc3RhbnQgZnJvbSB0aGVcbiAqIGBjdXJyZW50RnJhbWVgIHZhbHVlLiBIZXJlIGlzIHdoZXJlIG1vc3Qgb2YgdGhlIG1hZ2ljIGlzLlxuICogVGhlIHRyaWNrIGlzIHRvIHVzZSB0aGUgYHN0cm9rZURhc2hvZmZzZXRgIHN0eWxlIHByb3BlcnR5LlxuICpcbiAqIEZvciBvcHRpbWlzYXRpb24gcmVhc29ucywgYSBuZXcgcHJvcGVydHkgY2FsbGVkIGBwcm9ncmVzc2BcbiAqIGlzIGFkZGVkIGluIGVhY2ggaXRlbSBvZiBgbWFwYC4gVGhpcyBvbmUgY29udGFpbiB0aGUgY3VycmVudFxuICogcHJvZ3Jlc3Mgb2YgdGhlIHBhdGggZWxlbWVudC4gT25seSBpZiB0aGUgbmV3IHZhbHVlIGlzIGRpZmZlcmVudFxuICogdGhlIG5ldyB2YWx1ZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIERPTSBlbGVtZW50LiBUaGlzXG4gKiBtZXRob2Qgc2F2ZSBhIGxvdCBvZiByZXNvdXJjZXMgdG8gcmUtcmVuZGVyIHRoZSBTVkcuIEFuZCBjb3VsZFxuICogYmUgaW1wcm92ZWQgaWYgdGhlIGFuaW1hdGlvbiBjb3VsZG4ndCBiZSBwbGF5ZWQgZm9yd2FyZC5cbiAqXG4gKi9cblZpdnVzLnByb3RvdHlwZS50cmFjZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaSwgcHJvZ3Jlc3MsIHBhdGgsIGN1cnJlbnRGcmFtZTtcbiAgY3VycmVudEZyYW1lID1cbiAgICB0aGlzLmFuaW1UaW1pbmdGdW5jdGlvbih0aGlzLmN1cnJlbnRGcmFtZSAvIHRoaXMuZnJhbWVMZW5ndGgpICpcbiAgICB0aGlzLmZyYW1lTGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspIHtcbiAgICBwYXRoID0gdGhpcy5tYXBbaV07XG4gICAgcHJvZ3Jlc3MgPSAoY3VycmVudEZyYW1lIC0gcGF0aC5zdGFydEF0KSAvIHBhdGguZHVyYXRpb247XG4gICAgcHJvZ3Jlc3MgPSB0aGlzLnBhdGhUaW1pbmdGdW5jdGlvbihNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwcm9ncmVzcykpKTtcbiAgICBpZiAocGF0aC5wcm9ncmVzcyAhPT0gcHJvZ3Jlc3MpIHtcbiAgICAgIHBhdGgucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgIHBhdGguZWwuc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IE1hdGguZmxvb3IocGF0aC5sZW5ndGggKiAoMSAtIHByb2dyZXNzKSk7XG4gICAgICB0aGlzLnJlbmRlclBhdGgoaSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1ldGhvZCBmb3JjaW5nIHRoZSBicm93c2VyIHRvIHJlLXJlbmRlciBhIHBhdGggZWxlbWVudFxuICogZnJvbSBpdCdzIGluZGV4IGluIHRoZSBtYXAuIERlcGVuZGluZyBvbiB0aGUgYGZvcmNlUmVuZGVyYFxuICogdmFsdWUuXG4gKiBUaGUgdHJpY2sgaXMgdG8gcmVwbGFjZSB0aGUgcGF0aCBlbGVtZW50IGJ5IGl0J3MgY2xvbmUuXG4gKiBUaGlzIHByYWN0aWNlIGlzIG5vdCByZWNvbW1lbmRlZCBiZWNhdXNlIGl0J3MgYXNraW5nIG1vcmVcbiAqIHJlc3NvdXJjZXMsIHRvbyBtdWNoIERPTSBtYW51cHVsYXRpb24uLlxuICogYnV0IGl0J3MgdGhlIG9ubHkgd2F5IHRvIGxldCB0aGUgbWFnaWMgaGFwcGVuIG9uIElFLlxuICogQnkgZGVmYXVsdCwgdGhpcyBmYWxsYmFjayBpcyBvbmx5IGFwcGxpZWQgb24gSUUuXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCBQYXRoIGluZGV4XG4gKi9cblZpdnVzLnByb3RvdHlwZS5yZW5kZXJQYXRoID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgaWYgKHRoaXMuZm9yY2VSZW5kZXIgJiYgdGhpcy5tYXAgJiYgdGhpcy5tYXBbaW5kZXhdKSB7XG4gICAgdmFyIHBhdGhPYmogPSB0aGlzLm1hcFtpbmRleF0sXG4gICAgICBuZXdQYXRoID0gcGF0aE9iai5lbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgcGF0aE9iai5lbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdQYXRoLCBwYXRoT2JqLmVsKTtcbiAgICBwYXRoT2JqLmVsID0gbmV3UGF0aDtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGVuIHRoZSBTVkcgb2JqZWN0IGlzIGxvYWRlZCBhbmQgcmVhZHksXG4gKiB0aGlzIG1ldGhvZCB3aWxsIGNvbnRpbnVlIHRoZSBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBUaGlzIHRoaXMgbWFpbmx5IGR1ZSB0byB0aGUgY2FzZSBvZiBwYXNzaW5nIGFuXG4gKiBvYmplY3QgdGFnIGluIHRoZSBjb25zdHJ1Y3Rvci4gSXQgd2lsbCB3YWl0XG4gKiB0aGUgZW5kIG9mIHRoZSBsb2FkaW5nIHRvIGluaXRpYWxpc2UuXG4gKlxuICovXG5WaXZ1cy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAvLyBTZXQgb2JqZWN0IHZhcmlhYmxlc1xuICB0aGlzLmZyYW1lTGVuZ3RoID0gMDtcbiAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuICB0aGlzLm1hcCA9IFtdO1xuXG4gIC8vIFN0YXJ0XG4gIG5ldyBQYXRoZm9ybWVyKHRoaXMuZWwpO1xuICB0aGlzLm1hcHBpbmcoKTtcbiAgdGhpcy5zdGFydGVyKCk7XG5cbiAgaWYgKHRoaXMub25SZWFkeSkge1xuICAgIHRoaXMub25SZWFkeSh0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUcmlnZ2VyIHRvIHN0YXJ0IG9mIHRoZSBhbmltYXRpb24uXG4gKiBEZXBlbmRpbmcgb24gdGhlIGBzdGFydGAgdmFsdWUsIGEgZGlmZmVyZW50IHNjcmlwdFxuICogd2lsbCBiZSBhcHBsaWVkLlxuICpcbiAqIElmIHRoZSBgc3RhcnRgIHZhbHVlIGlzIG5vdCB2YWxpZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKiBFdmVuIGlmIHRlY2huaWNhbGx5LCB0aGlzIGlzIGltcG9zc2libGUuXG4gKlxuICovXG5WaXZ1cy5wcm90b3R5cGUuc3RhcnRlciA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHRoaXMuc3RhcnQpIHtcbiAgICBjYXNlICdtYW51YWwnOlxuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAnYXV0b3N0YXJ0JzpcbiAgICAgIHRoaXMucGxheSgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpblZpZXdwb3J0JzpcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoc2VsZi5pc0luVmlld3BvcnQoc2VsZi5wYXJlbnRFbCwgMSkpIHtcbiAgICAgICAgICAgIHNlbGYucGxheSgpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENvbnRyb2xzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqL1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIGFuaW1hdGlvbiBiZXR3ZWVuXG4gKiB0aHJlZSBkaWZmZXJlbnQgc3RhdGVzOiAnc3RhcnQnLCAncHJvZ3Jlc3MnLCAnZW5kJy5cbiAqIEByZXR1cm4ge3N0cmluZ30gSW5zdGFuY2Ugc3RhdHVzXG4gKi9cblZpdnVzLnByb3RvdHlwZS5nZXRTdGF0dXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY3VycmVudEZyYW1lID09PSAwXG4gICAgPyAnc3RhcnQnXG4gICAgOiB0aGlzLmN1cnJlbnRGcmFtZSA9PT0gdGhpcy5mcmFtZUxlbmd0aFxuICAgID8gJ2VuZCdcbiAgICA6ICdwcm9ncmVzcyc7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBpbnN0YW5jZSB0byB0aGUgaW5pdGlhbCBzdGF0ZSA6IHVuZHJhd1xuICogQmUgY2FyZWZ1bCwgaXQganVzdCByZXNldCB0aGUgYW5pbWF0aW9uLCBpZiB5b3UncmVcbiAqIHBsYXlpbmcgdGhlIGFuaW1hdGlvbiwgdGhpcyB3b24ndCBzdG9wIGl0LiBCdXQganVzdFxuICogbWFrZSBpdCBzdGFydCBmcm9tIHN0YXJ0LlxuICpcbiAqL1xuVml2dXMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNldEZyYW1lUHJvZ3Jlc3MoMCk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaW5zdGFuY2UgdG8gdGhlIGZpbmFsIHN0YXRlIDogZHJhd25cbiAqIEJlIGNhcmVmdWwsIGl0IGp1c3Qgc2V0IHRoZSBhbmltYXRpb24sIGlmIHlvdSdyZVxuICogcGxheWluZyB0aGUgYW5pbWF0aW9uIG9uIHJld2luZCwgdGhpcyB3b24ndCBzdG9wIGl0LlxuICogQnV0IGp1c3QgbWFrZSBpdCBzdGFydCBmcm9tIHRoZSBlbmQuXG4gKlxuICovXG5WaXZ1cy5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNldEZyYW1lUHJvZ3Jlc3MoMSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbGV2ZWwgb2YgcHJvZ3Jlc3Mgb2YgdGhlIGRyYXdpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHByb2dyZXNzIExldmVsIG9mIHByb2dyZXNzIHRvIHNldFxuICovXG5WaXZ1cy5wcm90b3R5cGUuc2V0RnJhbWVQcm9ncmVzcyA9IGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gIHByb2dyZXNzID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgcHJvZ3Jlc3MpKTtcbiAgdGhpcy5jdXJyZW50RnJhbWUgPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWVMZW5ndGggKiBwcm9ncmVzcyk7XG4gIHRoaXMudHJhY2UoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFBsYXkgdGhlIGFuaW1hdGlvbiBhdCB0aGUgZGVzaXJlZCBzcGVlZC5cbiAqIFNwZWVkIG11c3QgYmUgYSB2YWxpZCBudW1iZXIgKG5vIHplcm8pLlxuICogQnkgZGVmYXVsdCwgdGhlIHNwZWVkIHZhbHVlIGlzIDEuXG4gKiBCdXQgYSBuZWdhdGl2ZSB2YWx1ZSBpcyBhY2NlcHRlZCB0byBnbyBmb3J3YXJkLlxuICpcbiAqIEFuZCB3b3JrcyB3aXRoIGZsb2F0IHRvby5cbiAqIEJ1dCBkb24ndCBmb3JnZXQgd2UgYXJlIGluIEphdmFTY3JpcHQsIHNlIGJlIG5pY2VcbiAqIHdpdGggaGltIGFuZCBnaXZlIGhpbSBhIDEvMl54IHZhbHVlLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gc3BlZWQgQW5pbWF0aW9uIHNwZWVkIFtvcHRpb25hbF1cbiAqL1xuVml2dXMucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbihzcGVlZCwgY2FsbGJhY2spIHtcbiAgdGhpcy5pbnN0YW5jZUNhbGxiYWNrID0gbnVsbDtcblxuICBpZiAoc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5pbnN0YW5jZUNhbGxiYWNrID0gc3BlZWQ7IC8vIGZpcnN0IHBhcmFtZXRlciBpcyBhY3R1YWxseSB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICBzcGVlZCA9IG51bGw7XG4gIH0gZWxzZSBpZiAoc3BlZWQgJiYgdHlwZW9mIHNwZWVkICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVml2dXMgW3BsYXldOiBpbnZhbGlkIHNwZWVkJyk7XG4gIH1cbiAgLy8gaWYgdGhlIGZpcnN0IHBhcmFtZXRlciB3YXNuJ3QgdGhlIGNhbGxiYWNrLCBjaGVjayBpZiB0aGUgc2Vjb25kcyB3YXNcbiAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5pbnN0YW5jZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5pbnN0YW5jZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICB0aGlzLnNwZWVkID0gc3BlZWQgfHwgMTtcbiAgaWYgKCF0aGlzLmhhbmRsZSkge1xuICAgIHRoaXMuZHJhdygpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdG9wIHRoZSBjdXJyZW50IGFuaW1hdGlvbiwgaWYgb24gcHJvZ3Jlc3MuXG4gKiBTaG91bGQgbm90IHRyaWdnZXIgYW55IGVycm9yLlxuICpcbiAqL1xuVml2dXMucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaGFuZGxlKSB7XG4gICAgY2FuY2VsQW5pbUZyYW1lKHRoaXMuaGFuZGxlKTtcbiAgICB0aGlzLmhhbmRsZSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgdGhlIGluc3RhbmNlLlxuICogUmVtb3ZlIGFsbCBiYWQgc3R5bGluZyBhdHRyaWJ1dGVzIG9uIGFsbFxuICogcGF0aCB0YWdzXG4gKlxuICovXG5WaXZ1cy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN0b3AoKTtcbiAgdmFyIGksIHBhdGg7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLm1hcC5sZW5ndGg7IGkrKykge1xuICAgIHBhdGggPSB0aGlzLm1hcFtpXTtcbiAgICBwYXRoLmVsLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBudWxsO1xuICAgIHBhdGguZWwuc3R5bGUuc3Ryb2tlRGFzaGFycmF5ID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlclBhdGgoaSk7XG4gIH1cbn07XG5cbi8qKlxuICogVXRpbHMgbWV0aG9kc1xuICogaW5jbHVkZSBtZXRob2RzIGZyb20gQ29kcm9wc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKi9cblxuLyoqXG4gKiBNZXRob2QgdG8gYmVzdCBndWVzcyBpZiBhIHBhdGggc2hvdWxkIGFkZGVkIGludG9cbiAqIHRoZSBhbmltYXRpb24gb3Igbm90LlxuICpcbiAqIDEuIFVzZSB0aGUgYGRhdGEtdml2dXMtaWdub3JlYCBhdHRyaWJ1dGUgaWYgc2V0XG4gKiAyLiBDaGVjayBpZiB0aGUgaW5zdGFuY2UgbXVzdCBpZ25vcmUgaW52aXNpYmxlIHBhdGhzXG4gKiAzLiBDaGVjayBpZiB0aGUgcGF0aCBpcyB2aXNpYmxlXG4gKlxuICogRm9yIG5vdyB0aGUgdmlzaWJpbGl0eSBjaGVja2luZyBpcyB1bnN0YWJsZS5cbiAqIEl0IHdpbGwgYmUgdXNlZCBmb3IgYSBiZXRhIHBoYXNlLlxuICpcbiAqIE90aGVyIGltcHJvdm1lbnRzIGFyZSBwbGFubmVkLiBMaWtlIGRldGVjdGluZ1xuICogaXMgdGhlIHBhdGggZ290IGEgc3Ryb2tlIG9yIGEgdmFsaWQgb3BhY2l0eS5cbiAqL1xuVml2dXMucHJvdG90eXBlLmlzSW52aXNpYmxlID0gZnVuY3Rpb24oZWwpIHtcbiAgdmFyIHJlY3QsXG4gICAgaWdub3JlQXR0ciA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1pZ25vcmUnKTtcblxuICBpZiAoaWdub3JlQXR0ciAhPT0gbnVsbCkge1xuICAgIHJldHVybiBpZ25vcmVBdHRyICE9PSAnZmFsc2UnO1xuICB9XG5cbiAgaWYgKHRoaXMuaWdub3JlSW52aXNpYmxlKSB7XG4gICAgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiAhcmVjdC53aWR0aCAmJiAhcmVjdC5oZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlIGF0dHJpYnV0ZXMgb2YgYSBET00gZWxlbWVudCB0b1xuICogZ2V0IGFuIG9iamVjdCBvZiB7YXR0cmlidXRlTmFtZSA9PiBhdHRyaWJ1dGVWYWx1ZX1cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IGVsZW1lbnQgRE9NIGVsZW1lbnQgdG8gcGFyc2VcbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICBPYmplY3Qgb2YgYXR0cmlidXRlc1xuICovXG5WaXZ1cy5wcm90b3R5cGUucGFyc2VBdHRyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICB2YXIgYXR0cixcbiAgICBvdXRwdXQgPSB7fTtcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5hdHRyaWJ1dGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF0dHIgPSBlbGVtZW50LmF0dHJpYnV0ZXNbaV07XG4gICAgICBvdXRwdXRbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFJlcGx5IGlmIGFuIGVsZW1lbnQgaXMgaW4gdGhlIHBhZ2Ugdmlld3BvcnRcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IGVsIEVsZW1lbnQgdG8gb2JzZXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBoICBQZXJjZW50YWdlIG9mIGhlaWdodFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuVml2dXMucHJvdG90eXBlLmlzSW5WaWV3cG9ydCA9IGZ1bmN0aW9uKGVsLCBoKSB7XG4gIHZhciBzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsWSgpLFxuICAgIHZpZXdlZCA9IHNjcm9sbGVkICsgdGhpcy5nZXRWaWV3cG9ydEgoKSxcbiAgICBlbEJDUiA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgIGVsSGVpZ2h0ID0gZWxCQ1IuaGVpZ2h0LFxuICAgIGVsVG9wID0gc2Nyb2xsZWQgKyBlbEJDUi50b3AsXG4gICAgZWxCb3R0b20gPSBlbFRvcCArIGVsSGVpZ2h0O1xuXG4gIC8vIGlmIDAsIHRoZSBlbGVtZW50IGlzIGNvbnNpZGVyZWQgaW4gdGhlIHZpZXdwb3J0IGFzIHNvb24gYXMgaXQgZW50ZXJzLlxuICAvLyBpZiAxLCB0aGUgZWxlbWVudCBpcyBjb25zaWRlcmVkIGluIHRoZSB2aWV3cG9ydCBvbmx5IHdoZW4gaXQncyBmdWxseSBpbnNpZGVcbiAgLy8gdmFsdWUgaW4gcGVyY2VudGFnZSAoMSA+PSBoID49IDApXG4gIGggPSBoIHx8IDA7XG5cbiAgcmV0dXJuIGVsVG9wICsgZWxIZWlnaHQgKiBoIDw9IHZpZXdlZCAmJiBlbEJvdHRvbSA+PSBzY3JvbGxlZDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2aWV3cG9ydCBoZWlnaHQgaW4gcGl4ZWxzXG4gKlxuICogQHJldHVybiB7aW50ZWdlcn0gVmlld3BvcnQgaGVpZ2h0XG4gKi9cblZpdnVzLnByb3RvdHlwZS5nZXRWaWV3cG9ydEggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNsaWVudCA9IHRoaXMuZG9jRWxlbS5jbGllbnRIZWlnaHQsXG4gICAgaW5uZXIgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgaWYgKGNsaWVudCA8IGlubmVyKSB7XG4gICAgcmV0dXJuIGlubmVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjbGllbnQ7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBwYWdlIFkgb2Zmc2V0XG4gKlxuICogQHJldHVybiB7aW50ZWdlcn0gUGFnZSBZIG9mZnNldFxuICovXG5WaXZ1cy5wcm90b3R5cGUuc2Nyb2xsWSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IHRoaXMuZG9jRWxlbS5zY3JvbGxUb3A7XG59O1xuXG5zZXR1cEVudiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoVml2dXMucHJvdG90eXBlLmRvY0VsZW0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIGRvY3VtZW50IGVsZW1lbnRcbiAgICpcbiAgICogQHR5cGUge0RPTWVsZW1lbnR9XG4gICAqL1xuICBWaXZ1cy5wcm90b3R5cGUuZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBvclxuICAgKiBgc2V0VGltZW91dGAgZnVuY3Rpb24gZm9yIGRlcHJlY2F0ZWQgYnJvd3NlcnMuXG4gICAqXG4gICAqL1xuICByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICBmdW5jdGlvbigvKiBmdW5jdGlvbiAqLyBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICB9XG4gICAgKTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGBjYW5jZWxBbmltYXRpb25GcmFtZWAgb3JcbiAgICogYGNhbmNlbFRpbWVvdXRgIGZ1bmN0aW9uIGZvciBkZXByZWNhdGVkIGJyb3dzZXJzLlxuICAgKlxuICAgKi9cbiAgY2FuY2VsQW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cub0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgfVxuICAgICk7XG4gIH0pKCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHN0cmluZyB0byBpbnRlZ2VyLlxuICogSWYgdGhlIG51bWJlciBpcyBub3QgcG9zaXRpdmUgb3IgbnVsbFxuICogdGhlIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZVxuICogb3IgMCBpZiB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgU3RyaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBWYWx1ZSB0byByZXR1cm4gaWYgdGhlIHJlc3VsdCBwYXJzZWQgaXMgaW52YWxpZFxuICogQHJldHVybiB7bnVtYmVyfVxuICpcbiAqL1xucGFyc2VQb3NpdGl2ZUludCA9IGZ1bmN0aW9uKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIG91dHB1dCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIHJldHVybiBvdXRwdXQgPj0gMCA/IG91dHB1dCA6IGRlZmF1bHRWYWx1ZTtcbn07XG5cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gVml2dXM7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgLy8gbGlrZSBOb2RlLlxuICAgIG1vZHVsZS5leHBvcnRzID0gVml2dXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgd2luZG93LlZpdnVzID0gVml2dXM7XG4gIH1cblxufSgpKTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/vivus/dist/vivus.js\n");

/***/ })

};
;